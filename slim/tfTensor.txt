cmd >> python -c "import tensorflow as tf; one1=tf.ones(3,4); help(one1)" > tfTensor.txt

Help on Tensor in module tensorflow.python.framework.ops object:

class Tensor(_TensorLike)
 |  Represents one of the outputs of an `Operation`.
 |  
 |  A `Tensor` is a symbolic handle to one of the outputs of an
 |  `Operation`. It does not hold the values of that operation's output,
 |  but instead provides a means of computing those values in a
 |  TensorFlow @{tf.Session}.
 |  
 |  This class has two primary purposes:
 |  
 |  1. A `Tensor` can be passed as an input to another `Operation`.
 |     This builds a dataflow connection between operations, which
 |     enables TensorFlow to execute an entire `Graph` that represents a
 |     large, multi-step computation.
 |  
 |  2. After the graph has been launched in a session, the value of the
 |     `Tensor` can be computed by passing it to
 |     @{tf.Session.run}.
 |     `t.eval()` is a shortcut for calling
 |     `tf.get_default_session().run(t)`.
 |  
 |  In the following example, `c`, `d`, and `e` are symbolic `Tensor`
 |  objects, whereas `result` is a numpy array that stores a concrete
 |  value:
 |  
 |  ```python
 |  # Build a dataflow graph.
 |  c = tf.constant([[1.0, 2.0], [3.0, 4.0]])
 |  d = tf.constant([[1.0, 1.0], [0.0, 1.0]])
 |  e = tf.matmul(c, d)
 |  
 |  # Construct a `Session` to execute the graph.
 |  sess = tf.Session()
 |  
 |  # Execute the graph and store the value that `e` represents in `result`.
 |  result = sess.run(e)
 |  ```
 |  
 |  Method resolution order:
 |      Tensor
 |      _TensorLike
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __abs__ = abs(x, name=None)
 |      Computes the absolute value of a tensor.
 |      
 |      Given a tensor of real numbers `x`, this operation returns a tensor
 |      containing the absolute value of each element in `x`. For example, if x is
 |      an input element and y is an output element, this operation computes
 |      \\(y = |x|\\).
 |      
 |      Args:
 |        x: A `Tensor` or `SparseTensor` of type `float32`, `float64`, `int32`, or
 |          `int64`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` or `SparseTensor` the same size and type as `x` with absolute
 |          values.
 |  
 |  __add__ = binary_op_wrapper(x, y)
 |      Returns x + y element-wise.
 |      
 |      *NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `uint8`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`, `string`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __and__ = binary_op_wrapper(x, y)
 |      Returns the truth value of x AND y element-wise.
 |      
 |      *NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor` of type `bool`.
 |        y: A `Tensor` of type `bool`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __bool__(self)
 |      Dummy method to prevent a tensor from being used as a Python `bool`.
 |      
 |      This overload raises a `TypeError` when the user inadvertently
 |      treats a `Tensor` as a boolean (e.g. in an `if` statement). For
 |      example:
 |      
 |      ```python
 |      if tf.constant(True):  # Will raise.
 |        # ...
 |      
 |      if tf.constant(5) < tf.constant(7):  # Will raise.
 |        # ...
 |      ```
 |      
 |      This disallows ambiguities between testing the Python value vs testing the
 |      dynamic condition of the `Tensor`.
 |      
 |      Raises:
 |        `TypeError`.
 |  
 |  __div__ = binary_op_wrapper(x, y)
 |      Divide two values using Python 2 semantics. Used for Tensor.__div__.
 |      
 |      Args:
 |        x: `Tensor` numerator of real numeric type.
 |        y: `Tensor` denominator of real numeric type.
 |        name: A name for the operation (optional).
 |      Returns:
 |        `x / y` returns the quotient of x and y.
 |  
 |  __eq__(self, other)
 |      Return self==value.
 |  
 |  __floordiv__ = binary_op_wrapper(x, y)
 |      Divides `x / y` elementwise, rounding toward the most negative integer.
 |      
 |      The same as `tf.div(x,y)` for integers, but uses `tf.floor(tf.div(x,y))` for
 |      floating point arguments so that the result is always an integer (though
 |      possibly an integer represented as floating point).  This op is generated by
 |      `x // y` floor division in Python 3 and in Python 2.7 with
 |      `from __future__ import division`.
 |      
 |      Note that for efficiency, `floordiv` uses C semantics for negative numbers
 |      (unlike Python and Numpy).
 |      
 |      `x` and `y` must have the same type, and the result will have the same type
 |      as well.
 |      
 |      Args:
 |        x: `Tensor` numerator of real numeric type.
 |        y: `Tensor` denominator of real numeric type.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        `x / y` rounded down (except possibly towards zero for negative integers).
 |      
 |      Raises:
 |        TypeError: If the inputs are complex.
 |  
 |  __ge__ = greater_equal(x, y, name=None)
 |      Returns the truth value of (x >= y) element-wise.
 |      
 |      *NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `int64`, `uint8`, `int16`, `int8`, `uint16`, `half`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __getitem__ = _SliceHelper(tensor, slice_spec, var=None)
 |      Overload for Tensor.__getitem__.
 |      
 |      This operation extracts the specified region from the tensor.
 |      The notation is similar to NumPy with the restriction that
 |      currently only support basic indexing. That means that
 |      using a tensor as input is not currently allowed
 |      
 |      Some useful examples:
 |      
 |      ```python
 |      # strip leading and trailing 2 elements
 |      foo = tf.constant([1,2,3,4,5,6])
 |      print(foo[2:-2].eval()) # => [3,4]
 |      
 |      # skip every row and reverse every column
 |      foo = tf.constant([[1,2,3], [4,5,6], [7,8,9]])
 |      print(foo[::2,::-1].eval()) # => [[3,2,1], [9,8,7]]
 |      
 |      # Insert another dimension
 |      foo = tf.constant([[1,2,3], [4,5,6], [7,8,9]])
 |      print(foo[tf.newaxis, :, :].eval()) # => [[[3,2,1], [9,8,7]]]
 |      print(foo[:, tf.newaxis, :].eval()) # => [[[3,2,1]], [[9,8,7]]]
 |      print(foo[:, :, tf.newaxis].eval()) # => [[[3],[2],[1]], [[9],[8],[7]]]
 |      
 |      # Ellipses (3 equivalent operations)
 |      print(foo[tf.newaxis, :, :].eval()) # => [[[3,2,1], [9,8,7]]]
 |      print(foo[tf.newaxis, ...].eval()) # => [[[3,2,1], [9,8,7]]]
 |      print(foo[tf.newaxis].eval()) # => [[[3,2,1], [9,8,7]]]
 |      ```
 |      
 |      Notes:
 |        - `tf.newaxis` is `None` as in NumPy.
 |        - An implicit ellipsis is placed at the end of the `slice_spec`
 |        - NumPy advanced indexing is currently not supported.
 |      
 |      Args:
 |        tensor: An ops.Tensor object.
 |        slice_spec: The arguments to Tensor.__getitem__.
 |        var: In the case of variable slice assignment, the Variable
 |          object to slice (i.e. tensor is the read-only view of this
 |          variable).
 |      
 |      Returns:
 |        The appropriate slice of "tensor", based on "slice_spec".
 |      
 |      Raises:
 |        ValueError: If a slice range is negative size.
 |        TypeError: If the slice indices aren't int, slice, or Ellipsis.
 |  
 |  __gt__ = greater(x, y, name=None)
 |      Returns the truth value of (x > y) element-wise.
 |      
 |      *NOTE*: `Greater` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `int64`, `uint8`, `int16`, `int8`, `uint16`, `half`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __hash__(self)
 |      Return hash(self).
 |  
 |  __init__(self, op, value_index, dtype)
 |      Creates a new `Tensor`.
 |      
 |      Args:
 |        op: An `Operation`. `Operation` that computes this tensor.
 |        value_index: An `int`. Index of the operation's endpoint that produces
 |          this tensor.
 |        dtype: A `DType`. Type of elements stored in this tensor.
 |      
 |      Raises:
 |        TypeError: If the op is not an `Operation`.
 |  
 |  __invert__ = logical_not(x, name=None)
 |      Returns the truth value of NOT x element-wise.
 |      
 |      Args:
 |        x: A `Tensor` of type `bool`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __iter__(self)
 |      Dummy method to prevent iteration. Do not call.
 |      
 |      NOTE(mrry): If we register __getitem__ as an overloaded operator,
 |      Python will valiantly attempt to iterate over the Tensor from 0 to
 |      infinity.  Declaring this method prevents this unintended
 |      behavior.
 |      
 |      Raises:
 |        TypeError: when invoked.
 |  
 |  __le__ = less_equal(x, y, name=None)
 |      Returns the truth value of (x <= y) element-wise.
 |      
 |      *NOTE*: `LessEqual` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `int64`, `uint8`, `int16`, `int8`, `uint16`, `half`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __lt__ = less(x, y, name=None)
 |      Returns the truth value of (x < y) element-wise.
 |      
 |      *NOTE*: `Less` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `float32`, `float64`, `int32`, `int64`, `uint8`, `int16`, `int8`, `uint16`, `half`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __mod__ = binary_op_wrapper(x, y)
 |      Returns element-wise remainder of division. When `x < 0` xor `y < 0` is
 |      
 |      true, this follows Python semantics in that the result here is consistent
 |      with a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.
 |      
 |      *NOTE*: `FloorMod` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `int32`, `int64`, `float32`, `float64`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __mul__ = binary_op_wrapper(x, y)
 |      Dispatches cwise mul for "Dense*Dense" and "Dense*Sparse".
 |  
 |  __neg__ = _neg(x, name=None)
 |      Computes numerical negative value element-wise.
 |      
 |      I.e., \\(y = -x\\).
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __nonzero__(self)
 |      Dummy method to prevent a tensor from being used as a Python `bool`.
 |      
 |      This is the Python 2.x counterpart to `__bool__()` above.
 |      
 |      Raises:
 |        `TypeError`.
 |  
 |  __or__ = binary_op_wrapper(x, y)
 |      Returns the truth value of x OR y element-wise.
 |      
 |      *NOTE*: `LogicalOr` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor` of type `bool`.
 |        y: A `Tensor` of type `bool`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __pow__ = binary_op_wrapper(x, y)
 |      Computes the power of one value to another.
 |      
 |      Given a tensor `x` and a tensor `y`, this operation computes \\(x^y\\) for
 |      corresponding elements in `x` and `y`. For example:
 |      
 |      ```
 |      # tensor 'x' is [[2, 2], [3, 3]]
 |      # tensor 'y' is [[8, 16], [2, 3]]
 |      tf.pow(x, y) ==> [[256, 65536], [9, 27]]
 |      ```
 |      
 |      Args:
 |        x: A `Tensor` of type `float32`, `float64`, `int32`, `int64`, `complex64`,
 |         or `complex128`.
 |        y: A `Tensor` of type `float32`, `float64`, `int32`, `int64`, `complex64`,
 |         or `complex128`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`.
 |  
 |  __radd__ = r_binary_op_wrapper(y, x)
 |      Returns x + y element-wise.
 |      
 |      *NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `uint8`, `int8`, `int16`, `int32`, `int64`, `complex64`, `complex128`, `string`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __rand__ = r_binary_op_wrapper(y, x)
 |      Returns the truth value of x AND y element-wise.
 |      
 |      *NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor` of type `bool`.
 |        y: A `Tensor` of type `bool`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __rdiv__ = r_binary_op_wrapper(y, x)
 |      Divide two values using Python 2 semantics. Used for Tensor.__div__.
 |      
 |      Args:
 |        x: `Tensor` numerator of real numeric type.
 |        y: `Tensor` denominator of real numeric type.
 |        name: A name for the operation (optional).
 |      Returns:
 |        `x / y` returns the quotient of x and y.
 |  
 |  __repr__(self)
 |      Return repr(self).
 |  
 |  __rfloordiv__ = r_binary_op_wrapper(y, x)
 |      Divides `x / y` elementwise, rounding toward the most negative integer.
 |      
 |      The same as `tf.div(x,y)` for integers, but uses `tf.floor(tf.div(x,y))` for
 |      floating point arguments so that the result is always an integer (though
 |      possibly an integer represented as floating point).  This op is generated by
 |      `x // y` floor division in Python 3 and in Python 2.7 with
 |      `from __future__ import division`.
 |      
 |      Note that for efficiency, `floordiv` uses C semantics for negative numbers
 |      (unlike Python and Numpy).
 |      
 |      `x` and `y` must have the same type, and the result will have the same type
 |      as well.
 |      
 |      Args:
 |        x: `Tensor` numerator of real numeric type.
 |        y: `Tensor` denominator of real numeric type.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        `x / y` rounded down (except possibly towards zero for negative integers).
 |      
 |      Raises:
 |        TypeError: If the inputs are complex.
 |  
 |  __rmod__ = r_binary_op_wrapper(y, x)
 |      Returns element-wise remainder of division. When `x < 0` xor `y < 0` is
 |      
 |      true, this follows Python semantics in that the result here is consistent
 |      with a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.
 |      
 |      *NOTE*: `FloorMod` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `int32`, `int64`, `float32`, `float64`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __rmul__ = r_binary_op_wrapper(y, x)
 |      Dispatches cwise mul for "Dense*Dense" and "Dense*Sparse".
 |  
 |  __ror__ = r_binary_op_wrapper(y, x)
 |      Returns the truth value of x OR y element-wise.
 |      
 |      *NOTE*: `LogicalOr` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor` of type `bool`.
 |        y: A `Tensor` of type `bool`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor` of type `bool`.
 |  
 |  __rpow__ = r_binary_op_wrapper(y, x)
 |      Computes the power of one value to another.
 |      
 |      Given a tensor `x` and a tensor `y`, this operation computes \\(x^y\\) for
 |      corresponding elements in `x` and `y`. For example:
 |      
 |      ```
 |      # tensor 'x' is [[2, 2], [3, 3]]
 |      # tensor 'y' is [[8, 16], [2, 3]]
 |      tf.pow(x, y) ==> [[256, 65536], [9, 27]]
 |      ```
 |      
 |      Args:
 |        x: A `Tensor` of type `float32`, `float64`, `int32`, `int64`, `complex64`,
 |         or `complex128`.
 |        y: A `Tensor` of type `float32`, `float64`, `int32`, `int64`, `complex64`,
 |         or `complex128`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`.
 |  
 |  __rsub__ = r_binary_op_wrapper(y, x)
 |      Returns x - y element-wise.
 |      
 |      *NOTE*: `Sub` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __rtruediv__ = r_binary_op_wrapper(y, x)
 |  
 |  __rxor__ = r_binary_op_wrapper(y, x)
 |      x ^ y = (x | y) & ~(x & y).
 |  
 |  __str__(self)
 |      Return str(self).
 |  
 |  __sub__ = binary_op_wrapper(x, y)
 |      Returns x - y element-wise.
 |      
 |      *NOTE*: `Sub` supports broadcasting. More about broadcasting
 |      [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)
 |      
 |      Args:
 |        x: A `Tensor`. Must be one of the following types: `half`, `float32`, `float64`, `int32`, `int64`, `complex64`, `complex128`.
 |        y: A `Tensor`. Must have the same type as `x`.
 |        name: A name for the operation (optional).
 |      
 |      Returns:
 |        A `Tensor`. Has the same type as `x`.
 |  
 |  __truediv__ = binary_op_wrapper(x, y)
 |  
 |  __xor__ = binary_op_wrapper(x, y)
 |      x ^ y = (x | y) & ~(x & y).
 |  
 |  consumers(self)
 |      Returns a list of `Operation`s that consume this tensor.
 |      
 |      Returns:
 |        A list of `Operation`s.
 |  
 |  eval(self, feed_dict=None, session=None)
 |      Evaluates this tensor in a `Session`.
 |      
 |      Calling this method will execute all preceding operations that
 |      produce the inputs needed for the operation that produces this
 |      tensor.
 |      
 |      *N.B.* Before invoking `Tensor.eval()`, its graph must have been
 |      launched in a session, and either a default session must be
 |      available, or `session` must be specified explicitly.
 |      
 |      Args:
 |        feed_dict: A dictionary that maps `Tensor` objects to feed values.
 |          See @{tf.Session.run} for a
 |          description of the valid feed values.
 |        session: (Optional.) The `Session` to be used to evaluate this tensor. If
 |          none, the default session will be used.
 |      
 |      Returns:
 |        A numpy array corresponding to the value of this tensor.
 |  
 |  get_shape(self)
 |      Alias of Tensor.shape.
 |  
 |  set_shape(self, shape)
 |      Updates the shape of this tensor.
 |      
 |      This method can be called multiple times, and will merge the given
 |      `shape` with the current shape of this tensor. It can be used to
 |      provide additional information about the shape of this tensor that
 |      cannot be inferred from the graph alone. For example, this can be used
 |      to provide additional information about the shapes of images:
 |      
 |      ```python
 |      _, image_data = tf.TFRecordReader(...).read(...)
 |      image = tf.image.decode_png(image_data, channels=3)
 |      
 |      # The height and width dimensions of `image` are data dependent, and
 |      # cannot be computed without executing the op.
 |      print(image.shape)
 |      ==> TensorShape([Dimension(None), Dimension(None), Dimension(3)])
 |      
 |      # We know that each image in this dataset is 28 x 28 pixels.
 |      image.set_shape([28, 28, 3])
 |      print(image.shape)
 |      ==> TensorShape([Dimension(28), Dimension(28), Dimension(3)])
 |      ```
 |      
 |      Args:
 |        shape: A `TensorShape` representing the shape of this tensor.
 |      
 |      Raises:
 |        ValueError: If `shape` is not compatible with the current shape of
 |          this tensor.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |  
 |  device
 |      The name of the device on which this tensor will be produced, or None.
 |  
 |  dtype
 |      The `DType` of elements in this tensor.
 |  
 |  graph
 |      The `Graph` that contains this tensor.
 |  
 |  name
 |      The string name of this tensor.
 |  
 |  op
 |      The `Operation` that produces this tensor as an output.
 |  
 |  shape
 |      Returns the `TensorShape` that represents the shape of this tensor.
 |      
 |      The shape is computed using shape inference functions that are
 |      registered in the Op for each `Operation`.  See
 |      @{tf.TensorShape}
 |      for more details of what a shape represents.
 |      
 |      The inferred shape of a tensor is used to provide shape
 |      information without having to launch the graph in a session. This
 |      can be used for debugging, and providing early error messages. For
 |      example:
 |      
 |      ```python
 |      c = tf.constant([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
 |      
 |      print(c.shape)
 |      ==> TensorShape([Dimension(2), Dimension(3)])
 |      
 |      d = tf.constant([[1.0, 0.0], [0.0, 1.0], [1.0, 0.0], [0.0, 1.0]])
 |      
 |      print(d.shape)
 |      ==> TensorShape([Dimension(4), Dimension(2)])
 |      
 |      # Raises a ValueError, because `c` and `d` do not have compatible
 |      # inner dimensions.
 |      e = tf.matmul(c, d)
 |      
 |      f = tf.matmul(c, d, transpose_a=True, transpose_b=True)
 |      
 |      print(f.shape)
 |      ==> TensorShape([Dimension(3), Dimension(4)])
 |      ```
 |      
 |      In some cases, the inferred shape may have unknown dimensions. If
 |      the caller has additional information about the values of these
 |      dimensions, `Tensor.set_shape()` can be used to augment the
 |      inferred shape.
 |      
 |      Returns:
 |        A `TensorShape` representing the shape of this tensor.
 |  
 |  value_index
 |      The index of this tensor in the outputs of its `Operation`.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  OVERLOADABLE_OPERATORS = {'__abs__', '__add__', '__and__', '__div__', ...
 |  
 |  __array_priority__ = 100
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from _TensorLike:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)

